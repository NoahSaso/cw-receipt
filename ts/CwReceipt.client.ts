/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.17.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, Action, Expiration, Timestamp, Uint64, Cw20ReceiveMsg, QueryMsg, CheckedDenom, Addr, ListIdsForPayerResponse, ListPaymentsToIdResponse, PaymentWithId, Payment, BlockInfo, ListTotalsPaidByPayerResponse, Total, ListTotalsPaidToIdResponse, OutputResponse, OwnershipForString } from "./CwReceipt.types";
export interface CwReceiptReadOnlyInterface {
  contractAddress: string;
  output: () => Promise<OutputResponse>;
  listPaymentsToId: ({
    id,
    limit,
    startAfter
  }: {
    id: string;
    limit?: number;
    startAfter?: number;
  }) => Promise<ListPaymentsToIdResponse>;
  listTotalsPaidToId: ({
    id,
    limit,
    startAfter
  }: {
    id: string;
    limit?: number;
    startAfter?: CheckedDenom;
  }) => Promise<ListTotalsPaidToIdResponse>;
  listIdsForPayer: ({
    limit,
    payer,
    startAfter
  }: {
    limit?: number;
    payer: string;
    startAfter?: string;
  }) => Promise<ListIdsForPayerResponse>;
  listTotalsPaidByPayer: ({
    limit,
    payer,
    startAfter
  }: {
    limit?: number;
    payer: string;
    startAfter?: CheckedDenom;
  }) => Promise<ListTotalsPaidByPayerResponse>;
  ownership: () => Promise<OwnershipForString>;
}
export class CwReceiptQueryClient implements CwReceiptReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.output = this.output.bind(this);
    this.listPaymentsToId = this.listPaymentsToId.bind(this);
    this.listTotalsPaidToId = this.listTotalsPaidToId.bind(this);
    this.listIdsForPayer = this.listIdsForPayer.bind(this);
    this.listTotalsPaidByPayer = this.listTotalsPaidByPayer.bind(this);
    this.ownership = this.ownership.bind(this);
  }

  output = async (): Promise<OutputResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      output: {}
    });
  };
  listPaymentsToId = async ({
    id,
    limit,
    startAfter
  }: {
    id: string;
    limit?: number;
    startAfter?: number;
  }): Promise<ListPaymentsToIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_payments_to_id: {
        id,
        limit,
        start_after: startAfter
      }
    });
  };
  listTotalsPaidToId = async ({
    id,
    limit,
    startAfter
  }: {
    id: string;
    limit?: number;
    startAfter?: CheckedDenom;
  }): Promise<ListTotalsPaidToIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_totals_paid_to_id: {
        id,
        limit,
        start_after: startAfter
      }
    });
  };
  listIdsForPayer = async ({
    limit,
    payer,
    startAfter
  }: {
    limit?: number;
    payer: string;
    startAfter?: string;
  }): Promise<ListIdsForPayerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_ids_for_payer: {
        limit,
        payer,
        start_after: startAfter
      }
    });
  };
  listTotalsPaidByPayer = async ({
    limit,
    payer,
    startAfter
  }: {
    limit?: number;
    payer: string;
    startAfter?: CheckedDenom;
  }): Promise<ListTotalsPaidByPayerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      list_totals_paid_by_payer: {
        limit,
        payer,
        start_after: startAfter
      }
    });
  };
  ownership = async (): Promise<OwnershipForString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ownership: {}
    });
  };
}
export interface CwReceiptInterface extends CwReceiptReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  pay: ({
    id
  }: {
    id: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateOutput: ({
    output
  }: {
    output: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateOwnership: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class CwReceiptClient extends CwReceiptQueryClient implements CwReceiptInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.pay = this.pay.bind(this);
    this.updateOutput = this.updateOutput.bind(this);
    this.updateOwnership = this.updateOwnership.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, funds);
  };
  pay = async ({
    id
  }: {
    id: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pay: {
        id
      }
    }, fee, memo, funds);
  };
  updateOutput = async ({
    output
  }: {
    output: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_output: {
        output
      }
    }, fee, memo, funds);
  };
  updateOwnership = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_ownership: {}
    }, fee, memo, funds);
  };
}