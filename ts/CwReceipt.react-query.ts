/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.17.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, Uint128, Binary, Action, Expiration, Timestamp, Uint64, Cw20ReceiveMsg, QueryMsg, CheckedDenom, Addr, ListIdsForPayerResponse, ListPaymentsToIdResponse, PaymentWithId, Payment, BlockInfo, ListTotalsPaidByPayerResponse, Total, ListTotalsPaidToIdResponse, OutputResponse, OwnershipForString } from "./CwReceipt.types";
import { CwReceiptQueryClient, CwReceiptClient } from "./CwReceipt.client";
export const cwReceiptQueryKeys = {
  contract: ([{
    contract: "cwReceipt"
  }] as const),
  address: (contractAddress: string) => ([{ ...cwReceiptQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  output: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "output",
    args
  }] as const),
  listPaymentsToId: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "list_payments_to_id",
    args
  }] as const),
  listTotalsPaidToId: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "list_totals_paid_to_id",
    args
  }] as const),
  listIdsForPayer: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "list_ids_for_payer",
    args
  }] as const),
  listTotalsPaidByPayer: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "list_totals_paid_by_payer",
    args
  }] as const),
  ownership: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...cwReceiptQueryKeys.address(contractAddress)[0],
    method: "ownership",
    args
  }] as const)
};
export interface CwReceiptReactQuery<TResponse, TData = TResponse> {
  client: CwReceiptQueryClient;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface CwReceiptOwnershipQuery<TData> extends CwReceiptReactQuery<OwnershipForString, TData> {}
export function useCwReceiptOwnershipQuery<TData = OwnershipForString>({
  client,
  options
}: CwReceiptOwnershipQuery<TData>) {
  return useQuery<OwnershipForString, Error, TData>(cwReceiptQueryKeys.ownership(client.contractAddress), () => client.ownership(), options);
}
export interface CwReceiptListTotalsPaidByPayerQuery<TData> extends CwReceiptReactQuery<ListTotalsPaidByPayerResponse, TData> {
  args: {
    limit?: number;
    payer: string;
    startAfter?: CheckedDenom;
  };
}
export function useCwReceiptListTotalsPaidByPayerQuery<TData = ListTotalsPaidByPayerResponse>({
  client,
  args,
  options
}: CwReceiptListTotalsPaidByPayerQuery<TData>) {
  return useQuery<ListTotalsPaidByPayerResponse, Error, TData>(cwReceiptQueryKeys.listTotalsPaidByPayer(client.contractAddress, args), () => client.listTotalsPaidByPayer({
    limit: args.limit,
    payer: args.payer,
    startAfter: args.startAfter
  }), options);
}
export interface CwReceiptListIdsForPayerQuery<TData> extends CwReceiptReactQuery<ListIdsForPayerResponse, TData> {
  args: {
    limit?: number;
    payer: string;
    startAfter?: string;
  };
}
export function useCwReceiptListIdsForPayerQuery<TData = ListIdsForPayerResponse>({
  client,
  args,
  options
}: CwReceiptListIdsForPayerQuery<TData>) {
  return useQuery<ListIdsForPayerResponse, Error, TData>(cwReceiptQueryKeys.listIdsForPayer(client.contractAddress, args), () => client.listIdsForPayer({
    limit: args.limit,
    payer: args.payer,
    startAfter: args.startAfter
  }), options);
}
export interface CwReceiptListTotalsPaidToIdQuery<TData> extends CwReceiptReactQuery<ListTotalsPaidToIdResponse, TData> {
  args: {
    id: string;
    limit?: number;
    startAfter?: CheckedDenom;
  };
}
export function useCwReceiptListTotalsPaidToIdQuery<TData = ListTotalsPaidToIdResponse>({
  client,
  args,
  options
}: CwReceiptListTotalsPaidToIdQuery<TData>) {
  return useQuery<ListTotalsPaidToIdResponse, Error, TData>(cwReceiptQueryKeys.listTotalsPaidToId(client.contractAddress, args), () => client.listTotalsPaidToId({
    id: args.id,
    limit: args.limit,
    startAfter: args.startAfter
  }), options);
}
export interface CwReceiptListPaymentsToIdQuery<TData> extends CwReceiptReactQuery<ListPaymentsToIdResponse, TData> {
  args: {
    id: string;
    limit?: number;
    startAfter?: number;
  };
}
export function useCwReceiptListPaymentsToIdQuery<TData = ListPaymentsToIdResponse>({
  client,
  args,
  options
}: CwReceiptListPaymentsToIdQuery<TData>) {
  return useQuery<ListPaymentsToIdResponse, Error, TData>(cwReceiptQueryKeys.listPaymentsToId(client.contractAddress, args), () => client.listPaymentsToId({
    id: args.id,
    limit: args.limit,
    startAfter: args.startAfter
  }), options);
}
export interface CwReceiptOutputQuery<TData> extends CwReceiptReactQuery<OutputResponse, TData> {}
export function useCwReceiptOutputQuery<TData = OutputResponse>({
  client,
  options
}: CwReceiptOutputQuery<TData>) {
  return useQuery<OutputResponse, Error, TData>(cwReceiptQueryKeys.output(client.contractAddress), () => client.output(), options);
}
export interface CwReceiptUpdateOwnershipMutation {
  client: CwReceiptClient;
  msg: Action;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwReceiptUpdateOwnershipMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwReceiptUpdateOwnershipMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwReceiptUpdateOwnershipMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateOwnership(msg, fee, memo, funds), options);
}
export interface CwReceiptUpdateOutputMutation {
  client: CwReceiptClient;
  msg: {
    output: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwReceiptUpdateOutputMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwReceiptUpdateOutputMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwReceiptUpdateOutputMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateOutput(msg, fee, memo, funds), options);
}
export interface CwReceiptPayMutation {
  client: CwReceiptClient;
  msg: {
    id: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwReceiptPayMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwReceiptPayMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwReceiptPayMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.pay(msg, fee, memo, funds), options);
}
export interface CwReceiptReceiveMutation {
  client: CwReceiptClient;
  msg: Cw20ReceiveMsg;
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useCwReceiptReceiveMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, CwReceiptReceiveMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, CwReceiptReceiveMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.receive(msg, fee, memo, funds), options);
}